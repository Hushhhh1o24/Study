# 正则表达式

* [1.元字符](#元字符)
* [标题](#标题)
* [16.资源/参考文献](#16.资源/参考文献)

## 1.元字符

元字符(metacharacter）

| 代码/语法 | 说明                              | 例子                                     | 匹配字符                                                |
| --------- | --------------------------------- | ---------------------------------------- | ------------------------------------------------------- |
| .         | 匹配除换行符以外的任意字符        | hi.!                                     | hiA!    hi你!    hi6!                                   |
| *         | *前边的内容可以连续重复使用任意次 | hi.*!                                    |                                                         |
| \w        | 匹配字母或数字或下划线或汉字      | is\w*!                                   | isA!    is_!    is8!    isyou!                          |
| \s        | 匹配任意的空白符                  | i\sam\s.*!                               | i am lihua!    i am xiaoming!                           |
| \d        | 匹配数字                          | 0\d\d-\d\d\d\d\d\d\d\d 或者 0\d{2}-\d{8} | 010-12345678<br/>011-87654321                           |
| \b        | 匹配单词的开始或结束              | \bs\w*\b                                 | please use <u>spark</u> !<br/>paease use <u>storm</u> ! |
| ^         | 匹配字符串的开始                  | ^\d{5,12}$                               | 5位到12位数字                                           |
| $         | 匹配字符串的结束                  | 同上                                     | 同上                                                    |



## 2.字符转义

查找元字符本身办法指定它们，因为它们会被解释成别的意思，这时你就得使用\来取消这些字符的特殊意义。

例如：deerchao\.cn匹配deerchao.cn，C:\\Windows匹配C:\Windows。



## 3.重复

正则表达式中所有的**限定符**(指定数量的代码，例如*,{5,12}等)：

| 代码/语法 | 说明             | 例子   | 匹配字符          |
| --------- | ---------------- | ------ | ----------------- |
| *         | 重复零次或更多次 | hi.*!  | hi!    hiAABBCC!  |
| +         | 重复一次或更多次 | hi\w+! | hiw!    hiAABBCC! |
| ?         | 重复零次或一次   | hi\w?! | hi!    hiA!       |
| {n}       | 重复n次          |        |                   |
| {n,}      | 重复n次或更多次  |        |                   |
| {n,m}     | 重复n到m次       |        |                   |



## 4.字符类

只需要在方括号里列出即可。

格式：[我是字符]

例如：[aeiou]    -->    匹配其中任意字母    

​           [.?!]    -->    匹配其中任意标点 

​           [0-9]    -->    相当于 \d

​           [a-z0-9A-Z_]    -->    完全等同于\w（如果只考虑英文的话）

​           \(?0\d{2}[) -]?\d{8}    -->    *(010)88886666*，或*022-22334455*，或*02912345678*等



## 5.分支条件

正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用    |    把不同的规则分隔开。

例如：

0\d{2}-\d{8}|0\d{3}-\d{7}    -->    010-12345678或者0376-2233445

\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}    -->    010-12345678或者(010)-12345678或者01012345678或者(010)12345678



## 6.分组

用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了。

例如：

((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)    -->    IP地址



## 7.反义

| 代码/语法 | 说明                                       |
| --------- | ------------------------------------------ |
| \W        | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \S        | 匹配任意不是空白符的字符                   |
| \D        | 匹配任意非数字的字符                       |
| \B        | 匹配不是单词开头或结束的位置               |
| [^x]      | 匹配除了x以外的任意字符                    |
| [^aeiou]  | 匹配除了aeiou这几个字母以外的任意字符      |



## 8.反向引用

**组号分配**：分组0对应整个正则表达式，实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配——因此所有命名组的组号都大于未命名的组号，可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权。

**后向引用**用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。

例如：

\b(\w+)\b\s+\1\b    -->    用来匹配重复的单词

也可以自己**指定**子表达式的**组名**。要指定一个子表达式的组名，请使用这样的语法：(?<Word>\w+)(或者把尖括号换成'也行：(?'Word'\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组**捕获**的内容，你可以使用\k<Word>,所以上一个例子也可以写成这样：\b(?<Word>\w+)\b\s+\k<Word>\b。

| 分类     | 代码/语法    | 说明                                                         |
| -------- | ------------ | ------------------------------------------------------------ |
|          | (exp)        | 匹配exp,并捕获文本到自动命名的组里                           |
| 捕获     | (?<name>exp) | 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp) |
|          | (?:exp)      | 匹配exp,不捕获匹配的文本，也不给此分组分配组号               |
| -------- | ------------ | ------------------------------------------------------------ |
|          | (?=exp)      | 匹配exp前面的位置                                            |
| 零宽断言 | (?<=exp)     | 匹配exp后面的位置                                            |
|          | (?!exp)      | 匹配后面跟的不是exp的位置                                    |
|          | (?<!exp)     | 匹配前面不是exp的位置                                        |
| -------- | ------------ | ------------------------------------------------------------ |
| 注释     | (?#comment)  | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 |



## 9.零宽断言

断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。

(?=exp)也叫**零宽度正预测先行断言**，它断言自身出现的位置的后面能匹配表达式exp。

例如：I'm singing while you're dancing.

\b\w+(?=ing\b)    -->    sing和danc

(?<=exp)也叫**零宽度正回顾后发断言**，它断言自身出现的位置的前面能匹配表达式exp。

例如：reading a book

(?<=\bre)\w+\b    -->    ading

下面这个例子同时使用了这两种断言：

(?<=\s)\d+(?=\s)    -->    匹配以空白符间隔的数字(再次强调，不包括这些空白符)。



## 10.负向零宽断言

只是想要**确保某个字符没有出现，但并不想去匹配它**时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：q(?!u)\w*\b

**零宽度负预测先行断言**(?!exp)，断言此位置的后面不能匹配表达式exp。

例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。

同理，我们可以用(?<!exp),**零宽度负回顾后发断言**来断言此位置的前面不能匹配表达式exp

例如：(?<![a-z])\d{7}匹配前面不是小写字母的七位数字。

一个更复杂的例子：(?<=<(\w+)>).*(?=<\/\1>)匹配不包含属性的简单HTML标签内里的内容。(?<=<(\w+)>)指定了这样的**前缀**：被尖括号括起来的单词(比如可能是<b>)，然后是.*(任意的字符串),最后是一个**后缀**(?=<\/\1>)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。



## 11.注释

小括号的另一种用途是通过语法(?#comment)来包含注释。

例如：

2[0-4]\d(?#200-249)|25[0-5] (?#250-255)|[01]?\d\d?(?#0-199)



```
(?<=    # 断言要匹配的文本的前缀
<(\w+)> # 查找尖括号括起来的内容
# (即HTML/XML标签)
)       # 前缀结束
.*      # 匹配任意文本
(?=     # 断言要匹配的文本的后缀
<\/\1>  # 查找尖括号括起来的内容
# 查找尖括号括起来的内容
)       # 后缀结束
```



## 12.贪婪与懒惰

*贪婪匹配*

正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。

**懒惰匹配**

匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。

例如：

贪婪匹配：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索*aabab*的话，它会匹配整个字符串aabab。

懒惰匹配：a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于*aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。

| **代码/语法** | **说明**                        |
| ------------- | ------------------------------- |
| *?            | 重复任意次，但尽可能少重复      |
| +?            | 重复1次或更多次，但尽可能少重复 |
| ??            | 重复0次或1次，但尽可能少重复    |
| {n,m}?        | 重复n到m次，但尽可能少重复      |
| {n,}?         | 重复n次以上，但尽可能少重复     |



## 13.处理选项

## 14.平衡组/递归匹配

```
<                   #最外层的左括号
  [^<>]*            #它后面非括号的内容
  (
      (
        (?'Open'<)  #左括号，压入"Open"
        [^<>]*      #左括号后面的内容
      )+
      (
        (?'-Open'>) #右括号，弹出一个"Open"
        [^<>]*      #右括号后面的内容
      )+
  )*
  (?(Open)(?!))     #最外层的右括号前检查
                    #若还有未弹出的"Open"
                    #则匹配失败

>                #最外层的右括号
```

## 15.补充

| 代码/语法        | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
|\a               | 报警字符(打印它的效果是电脑嘀一声)                           |
| \b               | 通常是单词分界位置，但如果在字符类里使用代表退格             |
| \t               | 制表符，Tab                                                  |
| \r               | 回车                                                         |
| \v               | 竖向制表符                                                   |
| \f               | 换页符                                                       |
| \n               | 换行符                                                       |
| \e               | Escape                                                       |
| \0nn             | ASCII代码中八进制代码为nn的字符                              |
| \xnn             | ASCII代码中十六进制代码为nn的字符                            |
| \unnnn           | Unicode代码中十六进制代码为nnnn的字符                        |
| \cN              | ASCII控制字符。比如\cC代表Ctrl+C                             |
| \A               | 字符串开头(类似^，但不受处理多行选项的影响)                  |
| \Z               | 字符串结尾或行尾(不受处理多行选项的影响)                     |
| \z               | 字符串结尾(类似$，但不受处理多行选项的影响)                  |
| \G               | 当前搜索的开头                                               |
| \p{name}         | Unicode中命名为name的字符类，例如\p{IsGreek}                 |
| (?>exp)          | 贪婪子表达式                                                 |
| (?<x>-<y>exp)    | 平衡组                                                       |
| (?im-nsx:exp)    | 在子表达式exp中改变处理选项                                  |
| (?im-nsx)        | 为表达式后面的部分改变处理选项                               |
| (?(exp)yes\|no)  | 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no |
| (?(exp)yes)      | 同上，只是使用空表达式作为no                                 |
| (?(name)yes\|no) | 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no |
| (?(name)yes)     | 同上，只是使用空表达式作为no                                 |

## 16.资源/参考文献

1. [正则表达式30分钟入门教程](https://deerchao.cn/tutorials/regex/regex.htm#commenting)

